remove @+ from @+else in cweave.w and ctangle.w
(only to check that parsing works OK - after that revert back)

remove C++ keywords "new" and "delete"

make this example work in cweave:
@ @d eprintf(...) fprintf(stderr, __VA_ARGS__)

make in the following examples that space will be added before `L' in ctangle:
@ @c return L'\0';
@ @c case L'\0':
@ @c wprintf(PROG_NAME L"version 0.1\n");
and understand how newline is preserved in ctangle if it is used before `L' in these examples
(NOTE: in this case whitespace before L is not needed: L"two"L"strings")

at value 127 of hash_size cweave works OK, at value 113 it breaks in
@<Look for matches for new name among...@>=, because of Segmentation fault

-------------------

read goweave.pdf how grammar parsing is implemented there (maybe also see gowebman.pdf)

TODO: find out which productions are applied in this example

  @ @c
  typedef uint32_t pixel_t;

and why it does not print "\&{typedef} \&{uint32\_t} \&{pixel\_t}",
as it is done for "typedef short boolean;"

Find out via prductions tracing why pixel_t is not bold:

  @ @c
  typedef uint32_t pixel_t;
  void main(void)
  {
    int x = sizeof(pixel_t);
  }
+++++++++++++++++++++++++++++++++++++++++++++
NOTE (concerning the need for @s in "@s x int" example in cweav-format.ch): we use @s if type is defined after it is first used, like in the following example:
@ @c
my x;
typedef struct {
  int z;
} my;
my y;
This is due to the fact that typedef is not treated in phase one - syntax analysis is made and scraps are formed only in phase two, where it is too late. TODO: find which function exactly is used to mark an identifier when typedef is encountered - |id_lookup|? HINT: see this in cwebman.tex:
   \.{CWEAVE} knows that identifiers being
   defined with a \&{typedef} should become reserved words; thus you
   don't need format definitions very often.
Also, see #8 in "Additional features and caveats" in cwebman.

TODO (related to cweav-format.ch): in the following example
@
@c
we get
\M{1}
\Y\B\par
and if we do
@ @c
we get
\M{1}\B\par
The following code in |copy_TeX| causes this behavior:
  if (loc>limit && (finish_line(), get_line()==0)) return(new_section);
It makes out_line and out_ptr change, which causes |emit_space_if_needed|
in @<Translate the \CEE/...@> produce the \Y
BUT, according to this code from cweave.w, the first variant is valid syntax:
  ccode[' ']=ccode['\t']=ccode['\n']=ccode['\v']=ccode['\r']=ccode['\f']
     =ccode['*']=new_section;
